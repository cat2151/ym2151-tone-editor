Last updated: 2025-11-26


# プロジェクト概要生成プロンプト（来訪者向け）

## 生成するもの：
- projectを3行で要約する
- プロジェクトで使用されている技術スタックをカテゴリ別に整理して説明する
- プロジェクト全体のファイル階層ツリー（ディレクトリ構造を図解）
- プロジェクト全体のファイルそれぞれの説明
- プロジェクト全体の関数それぞれの説明
- プロジェクト全体の関数の呼び出し階層ツリー

## 生成しないもの：
- Issues情報（開発者向け情報のため）
- 次の一手候補（開発者向け情報のため）
- ハルシネーションしそうなもの（例、存在しない機能や計画を勝手に妄想する等）

## 出力フォーマット：
以下のMarkdown形式で出力してください：

```markdown
# Project Overview

## プロジェクト概要
[以下の形式で3行でプロジェクトを要約]
- [1行目の説明]
- [2行目の説明]
- [3行目の説明]

## 技術スタック
[使用している技術をカテゴリ別に整理して説明]
- フロントエンド: [フロントエンド技術とその説明]
- 音楽・オーディオ: [音楽・オーディオ関連技術とその説明]
- 開発ツール: [開発支援ツールとその説明]
- テスト: [テスト関連技術とその説明]
- ビルドツール: [ビルド・パース関連技術とその説明]
- 言語機能: [言語仕様・機能とその説明]
- 自動化・CI/CD: [自動化・継続的統合関連技術とその説明]
- 開発標準: [コード品質・統一ルール関連技術とその説明]

## ファイル階層ツリー
```
[プロジェクトのディレクトリ構造をツリー形式で表現]
```

## ファイル詳細説明
[各ファイルの役割と機能を詳細に説明]

## 関数詳細説明
[各関数の役割、引数、戻り値、機能を詳細に説明]

## 関数呼び出し階層ツリー
```
[関数間の呼び出し関係をツリー形式で表現]
```
```


以下のプロジェクト情報を参考にして要約を生成してください：

## プロジェクト情報
名前: 
説明: # ym2151-tone-editor

<p align="left">
  <a href="README.ja.md"><img src="https://img.shields.io/badge/🇯🇵-Japanese-red.svg" alt="Japanese"></a>
  <a href="README.md"><img src="https://img.shields.io/badge/🇺🇸-English-blue.svg" alt="English"></a>
</p>

YM2151（OPM）FM音源音色エディタ。Windows用。TUI。Rustで書かれています。

## 状況

開発中です。現在の進捗率は80%。残り20%はkeybinds追加と音色管理。

- 今後の展望
    - ※すべて検証用の仮仕様であり、頻繁に破壊的変更をします
    - 音色保存とGitHub管理に適したセーブの仕組みを構築する。後述。
    - 大幅なkeybind変更をする。後述。

## 機能

- YM2151音色パラメータを編集
- マウスだけでも操作可
- カーソルキーで移動、PageUp/PageDown/Home/Endで値を増減
- `P`または`SPACE`キーで音色プレビュー
- `ESC`キーで終了
- 終了時に音色を自動セーブし、次回に自動ロードして続きを編集可
- keybinds設定可

## コツ
- 画面いっぱいに表示したいとき：
  - Windows Terminalなら、`ALT+ENTER`や`F11`でウィンドウ最大化したあと、`CTRL`+`+`でフォントを拡大できます

## YM2151音色データ形式

### Parameters

| Parameter | Name | Range | Description |
|-----------|------|-------|-------------|
| DT | Detune | 0-7 | Fine frequency detuning (3 bits) |
| MUL | Multiplier | 0-15 | Frequency multiplier (4 bits) |
| TL | Total Level | 0-99 | Operator output level (7 bits, limited to 99) |
| KS | Key Scale | 0-3 | Key scaling (2 bits) |
| AR | Attack Rate | 0-31 | Envelope attack rate (5 bits) |
| D1R | Decay 1 Rate | 0-31 | First decay rate (5 bits) |
| D1L | Decay 1 Level | 0-15 | Sustain level (4 bits) |
| D2R | Decay 2 Rate | 0-15 | Second decay/sustain rate (4 bits) |
| RR | Release Rate | 0-15 | Envelope release rate (4 bits) |
| DT2 | Detune 2 | 0-3 | Coarse frequency detuning (2 bits) |
| AMS | AM Sensitivity | 0-3 | Amplitude modulation sensitivity (2 bits) |

## 動作要件

- Rust 1.70 以降

## ビルド

```bash
cargo build --release
```

## 実行

```bash
cargo run
```

または、コンパイルされたバイナリを直接実行：

```bash
./target/release/ym2151-tone-editor
```

## リアルタイム音声フィードバック（Windows限定）

エディタは、ym2151-log-play-serverライブラリの`ensure_server_ready()`関数を使用して、サーバーの準備を自動的に確保します。これにより、サーバーのインストール、起動、準備状況チェックが自動的に処理されます。

```bash
# 音色エディタを実行するだけ - サーバーは自動的にセットアップ・起動されます
cargo run
```

### 動作モード

エディタは2つのモードで動作します：

#### インタラクティブモード（デフォルト）

インタラクティブモードでは、サーバーが継続的にオーディオをストリーミングし、パラメータ変更時にレジスタ書き込みコマンドのみを送信します。これにより、より効率的でスムーズな音声フィードバックが提供されます。

#### レガシーモード

デフォルトでは、エディタは`send_json`を使用して名前付きパイプ経由で完全な音色データをJSON形式で送信します。パラメータが変更されるたびに、新しいJSON全体が送信されます。

### 比較

| 特徴 | レガシーモード | インタラクティブモード |
|------|---------------|---------------------|
| データ送信 | 完全なJSON | レジスタ書き込みのみ |
| 効率性 | 低い（毎回全データ送信） | 高い（変更箇所のみ送信） |
| 音声連続性 | パラメータ変更時に再起動 | 継続的なストリーミング |
| 用途 | 比較検証用 | 通常の編集作業 |

## 操作方法

※今後、破壊的変更されます。検証のためです

| キー | 動作 |
|-----|--------|
| **カーソル移動** | |
| 矢印キー（←↓↑→） | それぞれの方向にカーソルを移動 |
| **値の変更** | |
| `PageUp` / `e` | カーソル位置の値を増加 |
| `PageDown` / `q` | カーソル位置の値を減少 |
| `+` / `.` | 値を1増やす |
| `-` / `,` | 値を1減らす |
| `Shift` + `.` (`>`) | 値を10増やす |
| `Shift` + `,` (`<`) | 値を10減らす |
| `Home` | 現在のパラメータの最大値に設定 |
| `End` | 最小値（0）に設定 |
| `r` / `R` | ランダム値に設定（有効範囲内） |
| **マウス** | |
| `マウスホイール上` | マウスポインタ位置にカーソルを移動して値を増加 |
| `マウスホイール下` | マウスポインタ位置にカーソルを移動して値を減少 |
| **その他** | |
| `ESC` | 保存してアプリケーション終了 |

## コマンドラインオプション

| オプション | 説明 |
|--------|-------------|
| `--value-by-mouse-move` | レガシーマウス動作を有効化（マウスの左右移動でカーソル位置の値を変更） |

## 依存関係

- `ratatui` 0.28 - ターミナルUIフレームワーク
- `crossterm` 0.28 - クロスプラットフォームターミナル操作ライブラリ

## コンセプト
- 100msで起動、100msで音が鳴る ※数値は雑。1秒よりは大幅に短い程度のイメージ
- キーを押せば音が鳴るし音色も変化する
    - 「触っても鳴らないし編集できない、よくわからない」を優先して対策する
- カラフルに可視化
- シンプル
- 最低限の編集だけならとっつきやすい操作（カーソル、マウス）

## スコープ外、目指さないこと
- 高機能エディタ
    - 初心者から超上級者まで全員が満足する完璧な万能エディタ
    - 無制限のインテリジェントなUNDO
    - 各種インテリジェントでフルオート、わかりやすくミスなく使えて柔軟で高度な編集機能
- インタラクティブ
    - 仮想MIDIキーボードによる高度にインタラクティブな演奏、サーバも共有メモリを使った低レイテンシの高度なリアルタイム処理に変更
    - レスポンスのよい高度にインタラクティブな演奏全般
- GUI
    - グラフィカルな音色の可視化。専用ターミナルエミュレータによるエンベロープや波形のビジュアライズ、16msecで表示更新する高性能オシロスコープ
- 高機能なライブラリアン
    - すべての音色に柔軟な操作でわかりやすく素早くアクセス、プレビュー、選択、編集、高度にインテリジェントな版管理
    - 既存楽曲からのフルオートあるいはインタラクティブで高度な音色抽出、その成功率100%
    - 全てのYM2151音色フォーマットを自動判別して読み込み、自動判別成功率100%
    - 全てのFM音色フォーマットを自動判別と自動変換して読み込み、その成功率100%
- 高度な拡張性
    - オートメーションを利用した高度な音色作り
    - 8channelすべて、さらには複数YM2151を利用した高度な音色づくり
    - YM2151の枠組みを超えすべてのFM音源に対応
    - DAWやオーディオプラグインすべてに対応して、それぞれを演奏可能、それぞれのFM音源の音色のインポートとエクスポート

## 音色保存用のフォーマットを検討する
- これまでの課題
    - ym2151-logフォーマット
        - 行数の多いJSONデータ。
        - 1ファイルに複数音色バリエーションを入れることができない。
        - これをこのままGeneral MIDI用にGitHubでメンテするのはあまり現実的でない。
        - サーバ送信用として今後も使う。だが音色管理用のフォーマットとしては、もっと適切なものが必要という感触。
### 対策案
- 運用
    - 配置
        - `tones/general_midi/000_AcousticGrand.json`
        - メリット
            - 自己記述性
                - ディレクトリ階層とファイル名で、用途と音色がわかりやすい
    - commit
        - ym2151-tone-editor リポジトリに、1日0回～1回の頻度でcommit
- ファイルフォーマット
```
{
  "description": "GM:000 Acoustic Grand Piano family",
  "variations": [
    { "description": "GM:000 Bright Piano", "mml": "t120 o5 l4 cdefgab", "registers": "204F204C364037808003812D" },
    { "description": "GM:000 Soft Piano", "note_number": 60, "registers": "204F204C364037808001812D" }
  ]
}
```
- JSONファイルフォーマット説明
    - 本体はregisters。必須項目。
    - mml,note_number,descriptionは任意項目。
    - mmlとnote_numberは省略すると何が鳴るかはアプリ任せ、例えば中央ド
    - mmlとnote_numberを両方書いた場合にどちらが鳴るかもアプリ任せ、例えばnote_number、mml、の順番で交互に鳴る
- データフォーマット説明
    - アドレスとデータ
        - アドレス2文字、データ2文字、のペア、の繰り返し。
    - メリット
        - 構造化
            - jsonであり、自然言語のような曖昧さがなく、シンプルなcodeで読み書きが可能
        - 柔軟性
            - もし特定レジスタのみに絞り、それを特定の記述方法に固定するフォーマットの場合、以下のような問題がありうるが、それぞれを回避できる
                - 例、このフォーマットでは、必要な情報が不足
                - 例、どこまで記録すれば十分なフォーマットになるか、フォーマット検討コストがかかる
                - 例、あとからフォーマット変更したために、パーサや出力のcodeの変更や、マイグレーションが必要になる
                    - フォーマット変更とは、記述方法の変更や、対象レジスタの増減など
        - 自己記述性
            - descriptionで、可読性と自己記述性を担保、それはdir名とfilenameも同様
                - jsonであることも同様
        - バリエーション
            - 実用上、GM000でも多数のバリエーションがありうるので、
                - そこはjson内に配列で保持することで対処
        - 可読性
            - 1行で書き、description先頭なら可読性が高い。音色バリエーション名のlistとして扱える想定
        - 移植性
            - 移植性が高いフォーマット、このレベルなら楽に相互変換codeを書ける想定
        - 一意性
            - registersをunique IDとして利用することで、ある程度の一意性の恩恵がある想定
                - メリット。重複検知ができるので、過剰な音色ライブラリ肥大を多少防止できる可能性がある
                - メリット。ある音色を一意に識別したいとき、IDとして利用できる。
                    - descriptionが変更されていても検索できる。
                    - いろいろ取り扱いが楽になる可能性がある。
                - メリット。registersを使って検索すれば、「YM2151音色で、誰それのリポジトリにあるデータだ」がわかる。データに自己記述性がある。
                    - このためregistersは区切り文字を使わないフォーマットを保持することが必要。
                    - 前提として、GitHub管理で登録されていること、登録場所が自己記述的であること、はある。
                - 注意、あくまで、ある程度レベル。ほぼ同じ音色でも1bit違えば別IDなので
    - 補足
        - slot mask
            - registersにnote onを含むことで、slot maskを表現できる。アプリはそこからslot maskを抽出できる。ym2151-tone-editorが実装済み。
            - slot maskの用途は、編集しやすい2op音色edit体験の提供など。
        - 全256bytesのレジスタ情報すべてをjson保存、は推奨しない。アプリが想定外の動作となるリスクがある想定。
            - そこの精査や検討は、後回しにする。YAGNI。あとからアプリ側で対処できる想定。
        - モジュレータTLオートメーション等の高度な奏法はこの音色データに含めることができない点は留意されたい。
            - つまり、このフォーマットで表現しきれないような「高度な奏法を含む音色データ」は存在しうるし、それとの互換性は限定的なものとなる。
- 課題と対策
    - 課題、128個は手間
    - 対策、それ用に簡易的なcodeを書いて対処すれば十分対応可能な想定
        - 例えば音色名のlist128行を用意し、簡易codeを用意すれば、json filename生成や、descriptionの生成も楽な想定

## keybindsを検討する
- ※それぞれ切り分けて個別のissueにする。安全優先。混乱防止。
- ※ym2151-tone-editor.toml のkeybinds欄で設定可能にする想定
- コンセプト
    - カーソルキーとPage Up/Downだけで基本操作は完結する
    - 補足
        - ショートカットキーで素早い編集と、高機能、を補足する
        - mouse左クリックでカーソル移動、ホイールで値が増減、もスタンダードなので実装する
            - TUIで右クリックはわかりづらいので回避がよい
        - なお、終了など一部の機能はESCのみでいい、それはスタンダードである、という考え。
- +と-で値の増減。広く知られて伝わりやすいため、導入のUX改善となる考え。
- CTRL hjklでカーソル移動。CTRL npfbもカーソル移動。
    - カーソルキーなしの移動は、ほかのショートカットキーで実現できてはいるが、これらも使えるとUXがよい、という可能性がある、特に導入時。
- Pとspaceで演奏。今の音のまま連打できるのはUXがよいので。
- FでFB増加、SHIFT+FでFB減少とする。カーソルもFBに移動する。
    - 他の類似の操作も、カーソルジャンプと値の増減をセットで行う、それが素早い想定。検証する。
- Tで今の行のTL増加、SHIFT+Tで減少。
- Mで今の行のMUL増加、SHIFT+Mで減少。
    - 備忘、もしMがほかが優先なら、X。multipleならxは意味が近いというイメージ。
- A,D,S,Rで今の行のAR,D1R,D2R,RR増加、SHIFT+で減少。
    - 補足。WASDによるカーソル移動をやめる。この用途だとミスが多く、メリットを感じられなかった。左手を常時ホームポジションから左に1つずらす必要がある点でミスが多かった想定。
- LでD1L増加、SHIFT+Lで減少。
    - D1LのL。見出しでの説明がわかりやすい。
- 1,2,3,4でM1,C1,M2,C2の行に直接移動しつつ、カーソルのある列の値をup。
    - SHIFTキーを押しながらだとdown。
    - 用途は、OPを横断的に値の増減するとき、素早くやれる用。
        - 例、OP1やっててOP4upしたいとき、カーソルキー3回とpage upに対して、
            - 4なら1回なので、4倍高速になる。
    - 注意、数字は比較的タッチタイピングしづらいので、aliasでhjklも検証する。
- 5,6,7,8でOP1～4のSlotMaskのトグル。
    - SHIFTを押しながらだとsoloモードのトグル。
        - modulatorであっても、soloモード中は強制ALG7で鳴らすことで、
            - エンベロープ等を確認する用。そして強制SlotMaskが当該行だけonとなる。
                - このときのALGとSMは、特殊な色あるいは背景色にしてわかりやすく。
        - カーソルのある行が常にsoloモードとなる、つまりSMはカーソル移動で動的に変化する。
        - トグル解除すると、トグルonになる直前に保持していたALGに戻る。
            - SHIFT+5,6,7,8いずれでもトグル解除とする、まずシンプル仕様。
                - つまり2つのopのsoloはしない。まずシンプル優先。
- Kでmouseマルチカーソルlockのトグル。loc`K`で表示説明しやすい。
    - lockしたときは、Fキーなどを押しても、カーソル移動しない。
        - lock対象は複数可。それぞれmouseによる数値増減の対象になる。
        - 用途の想定は、エンベロープをまとめて増減しながらプレビューする用。
    - lockしていないときは、mouseの挙動は、
        - 左クリックした場所にカーソル移動して値up、
        - 右クリックした場所にカーソル移動して値down、とする
- `,.`で、Noteのdownとupとする。中央ドを中心にしたCイオニアンスケールとする。
    - ただし値の増減としても有力なので、今後keybind変更も想定する。


依存関係:
{}

## ファイル階層ツリー
📄 .gitignore
📄 Cargo.lock
📄 Cargo.toml
📄 LICENSE
📖 README.ja.md
📖 README.md
📄 _config.yml
📁 docs/
  📖 KEYBINDS.ja.md
📁 generated-docs/
📁 issue-notes/
  📖 100.md
  📖 101.md
  📖 102.md
  📖 103.md
  📖 104.md
  📖 105.md
  📖 106.md
  📖 107.md
  📖 108.md
  📖 109.md
  📖 110.md
  📖 111.md
  📖 112.md
  📖 113.md
  📖 114.md
  📖 115.md
  📖 95.md
  📖 96.md
  📖 97.md
  📖 99.md
📁 src/
  📄 app.rs
  📄 app_init.rs
  📄 audio.rs
  📄 config.rs
  📄 file_ops.rs
  📄 main.rs
  📄 midi_conversion.rs
  📄 models.rs
  📄 register.rs
  📁 tests/
    📄 app_tests.rs
    📄 file_ops_tests.rs
    📄 midi_conversion_tests.rs
    📄 mod.rs
    📄 register_tests.rs
    📄 ui_tests.rs
    📄 verbose_logging_tests.rs
  📄 ui.rs
📁 tones/
  📁 general_midi/
    📊 000_AcousticGrand.json
📄 ym2151-tone-editor.toml.example

## ファイル詳細分析


## 関数呼び出し階層
関数呼び出し階層を分析できませんでした

## プロジェクト構造（ファイル一覧）
README.ja.md
README.md
docs/KEYBINDS.ja.md
issue-notes/100.md
issue-notes/101.md
issue-notes/102.md
issue-notes/103.md
issue-notes/104.md
issue-notes/105.md
issue-notes/106.md
issue-notes/107.md
issue-notes/108.md
issue-notes/109.md
issue-notes/110.md
issue-notes/111.md
issue-notes/112.md
issue-notes/113.md
issue-notes/114.md
issue-notes/115.md
issue-notes/95.md
issue-notes/96.md
issue-notes/97.md
issue-notes/99.md
tones/general_midi/000_AcousticGrand.json

上記の情報を基に、プロンプトで指定された形式でプロジェクト概要を生成してください。
特に以下の点を重視してください：
- 技術スタックは各カテゴリごとに整理して説明
- ファイル階層ツリーは提供された構造をそのまま使用
- ファイルの説明は各ファイルの実際の内容と機能に基づく
- 関数の説明は実際に検出された関数の役割に基づく
- 関数呼び出し階層は実際の呼び出し関係に基づく


---
Generated at: 2025-11-26 07:08:18 JST
